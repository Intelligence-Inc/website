<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="index,follow">
    <link rel="canonical" href="https://intelligence.inc/">
    <title>Assistant that evolves with you | Intelligence Inc</title>
    <meta name="description" content="An AI assistant that stays in sync with your evolving life—tracking plans, commitments, routines, and conversations (including messages) to support long‑running, abstract goals.">
    <meta name="referrer" content="strict-origin-when-cross-origin">

    <!-- Icons and manifest -->
    <link rel="icon" href="/assets/favicon.ico" sizes="any">
    <link rel="icon" type="image/svg+xml" href="/assets/favicon.svg">
    <link rel="apple-touch-icon" href="/assets/apple-touch-icon.png">
    <link rel="manifest" href="/site.webmanifest">

    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://intelligence.inc/">
    <meta property="og:title" content="An assistant that evolves with you">
    <meta property="og:description" content="Goes beyond quick commands: stays in sync with the evolving details of your life—plans, commitments, context, and conversations—so it can handle long‑running, abstract goals and grow with you (messages are just one rich signal).">
    <meta property="og:image" content="https://intelligence.inc/assets/og.jpg">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Assistant that evolves with you">
    <meta name="twitter:description" content="Stays in sync with your life—plans, commitments, routines, and conversations—to support long‑running goals (messages are one input, not the whole story).">
    <meta name="twitter:image" content="https://intelligence.inc/assets/og.jpg">

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Organization",
      "name": "Intelligence Inc",
      "url": "https://intelligence.inc/",
      "logo": "https://intelligence.inc/assets/logo.png",
      "sameAs": [
        "https://www.linkedin.com/company/intelligence-inc-hq",
        "https://x.com/intelligencexhq",
        "https://github.com/intelligence-inc"
      ]
    }
    </script>
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "Intelligence Inc",
      "alternateName": "Intelligence",
      "url": "https://intelligence.inc/"
    }
    </script>

    <style>
    /* critical CSS: only what's needed to render initial viewport quickly */
    html{scroll-behavior:smooth}
    body{margin:0}
    </style>
    <style>
        :root {
            --bg-color: #ffffff;
            --cell-active: #a0a0a0;
            --grid-color: #e0e0e0;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-color: #000000;
                --cell-active: #606060;
                --grid-color: #2a2a2a;
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background-color: var(--bg-color);
            overflow: hidden;
            transition: background-color 0.3s ease;
            position: relative;
            width: 100vw;
            height: 100vh;
            touch-action: none;
            /* Enable advanced typographic features where supported */
            font-kerning: normal;
            font-variant-ligatures: common-ligatures contextual; /* modern ligatures */
            font-feature-settings: "kern" 1, "liga" 1, "clig" 1, "calt" 1; /* explicit */
            text-rendering: optimizeLegibility; /* hint for better kerning/ligatures */
            font-synthesis: none; /* avoid synthetic bold/italics that can harm spacing */
        }

        /* Progressive enhancement guard in case future syntax changes */
        @supports (font-kerning: normal) {
            body {
                font-kerning: normal;
            }
        }

        /* Only apply refined kerning & ligatures to proportional text (email) since monospace font doesn't benefit */
        .email {
            font-kerning: normal;
            font-variant-ligatures: common-ligatures contextual;
            font-feature-settings: "kern" 1, "liga" 1, "clig" 1, "calt" 1;
            text-rendering: optimizeLegibility;
            /* Light letter-spacing fallback when kerning not supported */
            letter-spacing: 0.02em;
        }

        /* When native kerning is confirmed, neutralize fallback letter-spacing */
        html.kerning .email {
            letter-spacing: 0;
        }

        #gameCanvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            cursor: crosshair;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .email {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            background: rgba(255, 255, 255, 0.3);
            padding: 5px 15px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 10;
        }
        
        .email a {
            color: var(--cell-active);
            text-decoration: none;
            transition: opacity 0.2s ease;
        }
        
        .email a:hover {
            opacity: 0.8;
        }
        
        @media (prefers-color-scheme: dark) {
            .email {
                background: rgba(0, 0, 0, 0.3);
            }
        }

        /* Accessible, visually-hidden content for screen readers & SEO */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0 0 0 0);
            clip-path: inset(50%);
            border: 0;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <main id="main-content">
        <canvas id="gameCanvas"></canvas>
        <div class="email"><a href="mailto:hello@intelligence.inc">hello@intelligence.inc</a></div>
        <section class="sr-only" aria-label="Product description">
            <h1>Assistant that evolves with you</h1>
            <p>Most assistants still echo early 2000s search: fine for atomic commands like setting a timer, brittle for open‑ended intentions such as “my parents are visiting in two months” or “I want to be a better parent.”</p>
            <p>Real progress on those requires continuity. An assistant has to maintain a living model of your shifting plans, commitments, context, and preferences—not just answer disconnected questions.</p>
            <p>We start by grounding in high‑signal personal traces: the way you coordinate plans, track logistics, share milestones, and negotiate commitments. Messages are one especially rich layer, but they are not the only one—routines, notes, decisions, and evolving goals also feed the model. By integrating these streams (with your control and consent), the assistant moves from reactive Q&A toward an adaptive intelligence that actually understands and grows with you.</p>
        </section>
    </main>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Kerning feature detection: apply class to enable refined styling
        (function(){
            try {
                const support = CSS && CSS.supports && (CSS.supports('font-kerning: normal') || CSS.supports('font-feature-settings: "kern" 1'));
                if (support) {
                    document.documentElement.classList.add('kerning');
                }
            } catch(e) { /* silent */ }
        })();
        
        const CELL_SIZE = 6;
        let GRID_WIDTH;
        let GRID_HEIGHT;
        
        let grid;
        let nextGrid;
        let isPlaying = true;
        let generation = 0;
        let animationId = null;
        let lastTime = 0;
        let updateInterval = 50;
        let isDrawing = false;
        
        // INTELLIGENCE patterns for desktop and mobile
        const INTELLIGENCE_PATTERNS = {
            desktop: [
                "                                                              ##                                                     ",
                "######                                 ####      ####         ##                                                     ",
                "######               ##                ####      ####         ##                                                     ",
                "  ##                 ##                  ##        ##                                                                ",
                "  ##     ## ####   #######     ####      ##        ##       ####       ### ##    ####    ## ####      ####     ####  ",
                "  ##     #######   #######    ######     ##        ##       ####      #######   ######   #######    #######   ###### ",
                "  ##     ###   ##    ##      ##    ##    ##        ##         ##     ###  ###  ##    ##  ###   ##   ##    #  ##    ##",
                "  ##     ##    ##    ##      ########    ##        ##         ##     ##    ##  ########  ##    ##  ##        ########",
                "  ##     ##    ##    ##      ########    ##        ##         ##     ##    ##  ########  ##    ##  ##        ########",
                "  ##     ##    ##    ##      ##          ##        ##         ##     ##    ##  ##        ##    ##  ##        ##      ",
                "  ##     ##    ##    ##      ###    #    ##        ##         ##     ###  ###  ###    #  ##    ##   ##    #  ###    #",
                "######   ##    ##    #####    #######    #####     #####   ########   #######   #######  ##    ##   #######   #######",
                "######   ##    ##     ####     #####      ####      ####   ########    ### ##    #####   ##    ##     ####     ##### ",
                "                                                                      #    ##                                        ",
                "                                                                      ######                                         ",
                "                                                                       ####                                          "
            ],
            mobile: [
                "                                                          ",
                " ######                                 ####      ####    ",
                " ######               ##                ####      ####    ",
                "   ##                 ##                  ##        ##    ",
                "   ##     ## ####   #######     ####      ##        ##    ",
                "   ##     #######   #######    ######     ##        ##    ",
                "   ##     ###   ##    ##      ##    ##    ##        ##    ",
                "   ##     ##    ##    ##      ########    ##        ##    ",
                "   ##     ##    ##    ##      ########    ##        ##    ",
                "   ##     ##    ##    ##      ##          ##        ##    ",
                "   ##     ##    ##    ##      ###    #    ##        ##    ",
                " ######   ##    ##    #####    #######    #####     ##### ",
                " ######   ##    ##     ####     #####      ####      #### ",
                "                                                          ",
                "                                                          ",
                "                                                          ",
                "   ##                                                     ",
                "   ##                                                     ",
                "   ##                                                     ",
                "                                                          ",
                " ####       ### ##    ####    ## ####      ####     ####  ",
                " ####      #######   ######   #######    #######   ###### ",
                "   ##     ###  ###  ##    ##  ###   ##   ##    #  ##    ##",
                "   ##     ##    ##  ########  ##    ##  ##        ########",
                "   ##     ##    ##  ########  ##    ##  ##        ########",
                "   ##     ##    ##  ##        ##    ##  ##        ##      ",
                "   ##     ###  ###  ###    #  ##    ##   ##    #  ###    #",
                "########   #######   #######  ##    ##   #######   #######",
                "########    ### ##    #####   ##    ##     ####     ##### ",
                "           #    ##                                        ",
                "           ######                                         ",
                "            ####                                          "
            ]
        };

        // Helper to pick pattern based on screen width
        function getIntelligencePattern() {
            // You can adjust the threshold as needed
            return window.innerWidth < 600 ? INTELLIGENCE_PATTERNS.mobile : INTELLIGENCE_PATTERNS.desktop;
        }
        
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            
            ctx.scale(dpr, dpr);
            
            const newGridWidth = Math.floor(window.innerWidth / CELL_SIZE);
            const newGridHeight = Math.floor(window.innerHeight / CELL_SIZE);
            
            // Only create new grids if dimensions actually changed
            if (newGridWidth !== GRID_WIDTH || newGridHeight !== GRID_HEIGHT) {
                const oldGridWidth = GRID_WIDTH || 0;
                const oldGridHeight = GRID_HEIGHT || 0;
                
                GRID_WIDTH = newGridWidth;
                GRID_HEIGHT = newGridHeight;
                
                const newGrid = createGrid();
                const newNextGrid = createGrid();
                
                if (grid && grid.length > 0 && grid[0].length > 0) {
                    // Calculate offsets to keep content centered
                    const offsetX = Math.floor((newGridWidth - oldGridWidth) / 2);
                    const offsetY = Math.floor((newGridHeight - oldGridHeight) / 2);
                    
                    // Copy old grid content to new grid with centering
                    for (let y = 0; y < oldGridHeight; y++) {
                        for (let x = 0; x < oldGridWidth; x++) {
                            const newX = x + offsetX;
                            const newY = y + offsetY;
                            
                            if (newX >= 0 && newX < GRID_WIDTH && 
                                newY >= 0 && newY < GRID_HEIGHT &&
                                grid[y] && grid[y][x]) {
                                newGrid[newY][newX] = grid[y][x];
                            }
                        }
                    }
                }
                
                grid = newGrid;
                nextGrid = newNextGrid;
            }
            
            drawGrid();
        }
        
        function createGrid() {
            if (!GRID_WIDTH || !GRID_HEIGHT || GRID_WIDTH <= 0 || GRID_HEIGHT <= 0) {
                return [];
            }
            return Array(GRID_HEIGHT).fill(null).map(() => Array(GRID_WIDTH).fill(0));
        }
        
        function drawGrid() {
            if (!grid || !GRID_WIDTH || !GRID_HEIGHT) return;
            
            const styles = getComputedStyle(document.documentElement);
            const bgColor = styles.getPropertyValue('--bg-color');
            const activeColor = styles.getPropertyValue('--cell-active');
            const gridColor = styles.getPropertyValue('--grid-color');
            
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
            
            // Draw grid lines
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 0.5;
            
            for (let x = 0; x <= GRID_WIDTH; x++) {
                ctx.beginPath();
                ctx.moveTo(x * CELL_SIZE, 0);
                ctx.lineTo(x * CELL_SIZE, GRID_HEIGHT * CELL_SIZE);
                ctx.stroke();
            }
            
            for (let y = 0; y <= GRID_HEIGHT; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * CELL_SIZE);
                ctx.lineTo(GRID_WIDTH * CELL_SIZE, y * CELL_SIZE);
                ctx.stroke();
            }
            
            // Draw cells
            for (let y = 0; y < GRID_HEIGHT && y < grid.length; y++) {
                for (let x = 0; x < GRID_WIDTH && x < grid[y].length; x++) {
                    if (grid[y][x]) {
                        ctx.fillStyle = activeColor;
                        ctx.fillRect(x * CELL_SIZE + 1, y * CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);
                    }
                }
            }
        }
        
        function countNeighbors(x, y) {
            if (!grid || !grid.length) return 0;
            
            let count = 0;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = (x + dx + GRID_WIDTH) % GRID_WIDTH;
                    const ny = (y + dy + GRID_HEIGHT) % GRID_HEIGHT;
                    if (grid[ny] && grid[ny][nx]) {
                        count += grid[ny][nx];
                    }
                }
            }
            return count;
        }
        
        function updateGrid() {
            if (!grid || !nextGrid || !GRID_WIDTH || !GRID_HEIGHT) return;
            
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (!grid[y] || !nextGrid[y]) continue;
                    
                    const neighbors = countNeighbors(x, y);
                    const alive = grid[y][x];
                    
                    if (alive && (neighbors === 2 || neighbors === 3)) {
                        nextGrid[y][x] = 1;
                    } else if (!alive && neighbors === 3) {
                        nextGrid[y][x] = 1;
                    } else {
                        nextGrid[y][x] = 0;
                    }
                }
            }
            
            [grid, nextGrid] = [nextGrid, grid];
            generation++;
        }
        
        function gameLoop(currentTime) {
            if (currentTime - lastTime >= updateInterval) {
                updateGrid();
                drawGrid();
                lastTime = currentTime;
            }
            
            if (isPlaying) {
                animationId = requestAnimationFrame(gameLoop);
            }
        }
        
        function clearGrid() {
            grid = createGrid();
            generation = 0;
            drawGrid();
        }
        
        function drawIntelligence() {
            clearGrid();
            if (!grid || !GRID_WIDTH || !GRID_HEIGHT) return;
            const pattern = getIntelligencePattern();
            // Infer pattern height and width
            const patternHeight = pattern.length;
            let patternWidth = 0;
            // Find the actual width of the pattern (rightmost non-space character)
            for (let y = 0; y < patternHeight; y++) {
                const row = pattern[y];
                for (let x = row.length - 1; x >= 0; x--) {
                    if (row[x] !== ' ') {
                        patternWidth = Math.max(patternWidth, x + 1);
                    }
                }
            }
            // Center based on actual content width
            const startX = Math.floor((GRID_WIDTH - patternWidth) / 2);
            const startY = Math.floor((GRID_HEIGHT - patternHeight) / 2);
            for (let y = 0; y < patternHeight; y++) {
                const row = pattern[y];
                for (let x = 0; x < row.length; x++) {
                    const gridX = startX + x;
                    const gridY = startY + y;
                    if (gridX >= 0 && gridX < GRID_WIDTH && 
                        gridY >= 0 && gridY < GRID_HEIGHT && 
                        grid[gridY] && row[x] !== ' ') {
                        grid[gridY][gridX] = 1;
                    }
                }
            }
            generation = 0;
            drawGrid();
        }
        
        function getCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            let x, y;
            
            if (e.touches) {
                x = e.touches[0].clientX - rect.left;
                y = e.touches[0].clientY - rect.top;
            } else {
                x = e.clientX - rect.left;
                y = e.clientY - rect.top;
            }
            
            const gridX = Math.floor(x / CELL_SIZE);
            const gridY = Math.floor(y / CELL_SIZE);
            
            return {
                x: gridX,
                y: gridY
            };
        }
        
        let lastDrawnX = -1;
        let lastDrawnY = -1;
        let clickStartX = -1;
        let clickStartY = -1;
        let hasMoved = false;
        
        function drawLine(x0, y0, x1, y1) {
            // Bresenham's line algorithm to fill gaps
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = x0 < x1 ? 1 : -1;
            const sy = y0 < y1 ? 1 : -1;
            let err = dx - dy;
            let x = x0;
            let y = y0;
            
            while (true) {
                setCell(x, y);
                
                if (x === x1 && y === y1) break;
                
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y += sy;
                }
            }
        }
        
        function setCell(x, y) {
            if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT && grid && grid[y]) {
                grid[y][x] = 1;
                drawGrid();
            }
        }

        // Interesting Game of Life patterns (relative coordinate sets)
        const LIFE_PATTERNS = [
            { // Glider
                name: 'glider',
                cells: [
                    [1,0],[2,1],[0,2],[1,2],[2,2]
                ], width: 3, height: 3, canRotate: true
            },
            { // Small exploder
                name: 'small-exploder',
                cells: [
                    [1,0],
                    [0,1],[1,1],[2,1],
                    [0,2],[2,2],
                    [1,3]
                ], width: 3, height: 4, canRotate: true
            },
            { // Blinker (oscillator period 2)
                name: 'blinker',
                cells: [ [0,0],[1,0],[2,0] ], width: 3, height: 1, canRotate: true
            },
            { // Toad (oscillator period 2)
                name: 'toad',
                cells: [
                    [1,0],[2,0],[3,0],
                    [0,1],[1,1],[2,1]
                ], width: 4, height: 2, canRotate: false
            },
            { // Beacon (oscillator period 2)
                name: 'beacon',
                cells: [
                    [0,0],[1,0],[0,1],[1,1],
                    [2,2],[3,2],[2,3],[3,3]
                ], width: 4, height: 4, canRotate: false
            }
        ];

        function rotateCells(cells, width, height) {
            // Rotate 90deg clockwise
            return cells.map(([x,y]) => [height - 1 - y, x]);
        }

        function maybeRotate(pattern) {
            const rotations = pattern.canRotate ? Math.floor(Math.random()*4) : 0; // 0-3
            let cells = pattern.cells;
            let w = pattern.width, h = pattern.height;
            for (let i=0;i<rotations;i++) {
                cells = rotateCells(cells, w, h);
                [w,h] = [h,w];
            }
            return { cells, width: w, height: h };
        }

        function placeRandomPattern(x, y) {
            if (!grid || !GRID_WIDTH || !GRID_HEIGHT) return;
            const pattern = LIFE_PATTERNS[Math.floor(Math.random()*LIFE_PATTERNS.length)];
            const rotated = maybeRotate(pattern);
            const w = rotated.width || pattern.width;
            const h = rotated.height || pattern.height;
            // Adjust origin if near edges so pattern fits fully
            let originX = x - Math.floor(w / 2);
            let originY = y - Math.floor(h / 2);
            if (originX + w > GRID_WIDTH) originX = GRID_WIDTH - w;
            if (originY + h > GRID_HEIGHT) originY = GRID_HEIGHT - h;
            if (originX < 0) originX = 0;
            if (originY < 0) originY = 0;
            for (const [cx, cy] of rotated.cells) {
                const gx = originX + cx;
                const gy = originY + cy;
                if (gx >= 0 && gx < GRID_WIDTH && gy >= 0 && gy < GRID_HEIGHT && grid[gy]) {
                    grid[gy][gx] = 1;
                }
            }
            drawGrid();
        }
        
        // Mouse events
        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();
            isDrawing = true;
            const coords = getCoordinates(e);
            clickStartX = coords.x;
            clickStartY = coords.y;
            hasMoved = false;
            lastDrawnX = coords.x;
            lastDrawnY = coords.y;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (isDrawing) {
                e.preventDefault();
                const coords = getCoordinates(e);
                if (coords.x !== lastDrawnX || coords.y !== lastDrawnY) {
                    hasMoved = true;
                }
                
                // Draw a line from last position to current position
                if (lastDrawnX !== -1 && lastDrawnY !== -1) {
                    drawLine(lastDrawnX, lastDrawnY, coords.x, coords.y);
                } else {
                    setCell(coords.x, coords.y);
                }
                
                lastDrawnX = coords.x;
                lastDrawnY = coords.y;
            }
        });
        
        canvas.addEventListener('mouseup', (e) => {
            e.preventDefault();
            if (!hasMoved && clickStartX !== -1 && clickStartY !== -1) {
                placeRandomPattern(clickStartX, clickStartY);
            }
            isDrawing = false;
            lastDrawnX = -1;
            lastDrawnY = -1;
            clickStartX = -1;
            clickStartY = -1;
            hasMoved = false;
        });
        
        canvas.addEventListener('mouseleave', () => {
            isDrawing = false;
            lastDrawnX = -1;
            lastDrawnY = -1;
            clickStartX = -1;
            clickStartY = -1;
            hasMoved = false;
        });
        
        // Touch events
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isDrawing = true;
            const coords = getCoordinates(e);
            clickStartX = coords.x;
            clickStartY = coords.y;
            hasMoved = false;
            lastDrawnX = coords.x;
            lastDrawnY = coords.y;
        });
        
        canvas.addEventListener('touchmove', (e) => {
            if (isDrawing) {
                e.preventDefault();
                const coords = getCoordinates(e);
                if (coords.x !== lastDrawnX || coords.y !== lastDrawnY) {
                    hasMoved = true;
                }
                
                // Draw a line from last position to current position
                if (lastDrawnX !== -1 && lastDrawnY !== -1) {
                    drawLine(lastDrawnX, lastDrawnY, coords.x, coords.y);
                } else {
                    setCell(coords.x, coords.y);
                }
                
                lastDrawnX = coords.x;
                lastDrawnY = coords.y;
            }
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (!hasMoved && clickStartX !== -1 && clickStartY !== -1) {
                placeRandomPattern(clickStartX, clickStartY);
            }
            isDrawing = false;
            lastDrawnX = -1;
            lastDrawnY = -1;
            clickStartX = -1;
            clickStartY = -1;
            hasMoved = false;
        });
        
        // Initialize
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        drawIntelligence();
        
        // Wait for page to be fully loaded and visible before autoplay
        let hasStarted = false;
        
        function startGameWhenReady() {
            // Start only when page fully loaded AND tab visible
            if (hasStarted) return;
            if (document.readyState === 'complete' && document.visibilityState === 'visible') {
                hasStarted = true; // prevent multiple timers
                setTimeout(() => {
                    lastTime = 0;
                    gameLoop(0);
                }, 1000);
            }
        }
        
        // Try to start when various conditions are met
        window.addEventListener('load', () => {
            console.log('Window load event fired');
            startGameWhenReady();
        });
        
        document.addEventListener('visibilitychange', () => {
            console.log('Visibility change event fired');
            startGameWhenReady();
        });
        
        window.addEventListener('focus', () => {
            console.log('Window focus event fired');
            startGameWhenReady();
        });
        
        // Also check periodically in case events don't fire as expected
        console.log('Starting periodic check interval');
        const checkInterval = setInterval(() => {
            console.log('Periodic check...');
            startGameWhenReady();
            if (hasStarted) {
                console.log('Game started, clearing interval');
                clearInterval(checkInterval);
            }
        }, 100);
    </script>
</body>
</html>
